 ## ğŸ¤” ìŠ¤íŠ¸ë¦¼ì´ë€?
 
 > ìŠ¤íŠ¸ë¦¼ ì‚¬ìš© ì˜ˆì‹œ
 
 ```java
 public void static main(String[] args){ 
    List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry", "fig");
    // ìŠ¤íŠ¸ë¦¼ 
    List<String> result = list.stream()
                                .map(s -> s.toUpperCase())
                                .toList;
    System.out.println(result);
 }
 ```
 
 - `ìŠ¤íŠ¸ë¦¼` - `ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ë¼ì¸` - `ì¢…ë‹¨ ì—°ì‚°` ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤.
 
 - `ìŠ¤íŠ¸ë¦¼` ì•ˆì˜ ë°ì´í„° ì›ì†Œë“¤ì€ ê°ì²´ ì°¸ì¡°ë‚˜ ê¸°ë³¸ íƒ€ì…(int, long double) ê°’ì´ë‹¤.
 
 - `ì¤‘ê°„ ì—°ì‚°`ì€ **ìŠ¤íŠ¸ë¦¼ì„ ì–´ë– í•œ ë°©ì‹ìœ¼ë¡œ ë³€í™˜**í•˜ëŠ” ê²ƒìœ¼ë¡œ, íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡± ëª»í•˜ëŠ” ì›ì†Œë¥¼ ê±¸ëŸ¬ë‚¼ ìˆ˜ë„ ìˆë‹¤.
 
 - ë§ˆì§€ë§‰ìœ¼ë¡œ ë³€í™˜ê²°ê³¼ë¥¼ `ì¢…ë‹¨ ì—°ì‚°`ì„ í†µí•´ ì‚°ì¶œí•´ë‚¸ë‹¤.
 
> âš ï¸ ì¢…ë‹¨ ì—°ì‚°ì´ ì—†ëŠ” ìŠ¤í‹¤ íŒŒì´í”„ë¼ì¸ì€ ì•„ë¬´ì¼ë„ í•˜ì§€ ì•Šì€ no-apì™€ ë™ì¼í•˜ë‹ˆ, ì£¼ì˜í•˜ì

## ğŸ˜ ìŠ¤íŠ¸ë¦¼ íŠ¹ì§•

1. í”Œë£¨ì–¸íŠ¸ API(fluent API) ì´ë‹¤.

    - íŒŒì´í”„ë¼ì¸ í•˜ë‚˜ë¥¼ êµ¬ì„±í•˜ëŠ” ëª¨ë“  í˜¸ì¶œì„ ì—°ê²°í•˜ì—¬ ë‹¨ í•˜ë‚˜ì˜ í‘œí˜„ì‹ìœ¼ë¡œ ì™„ì„±í•  ìˆ˜ ìˆë‹¤.
    
    - ì¦‰ íŒŒì´í”„ë¼ì¸ ì—¬ëŸ¬ ê°œë¥¼ ì—°ê²°í•´ í•˜ë‚˜ë¡œ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
    
2. ê¸°ë³¸ì ìœ¼ë¡œ ìˆœì°¨ì ìœ¼ë¡œ ì§„í–‰ë˜ì§€ë§Œ, ë³‘ë ¬ ì§„í–‰ë„ ê°€ëŠ¥í•˜ë‹¤.

    - `parallel` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ì£¼ê¸°ë§Œ í•˜ë©´ ê°€ëŠ¥í•˜ë‹¤.
    
    - í•˜ì§€ë§Œ íš¨ê³¼ë¥¼ ë³¼ ìˆ˜ ìˆëŠ” ìƒí™©ì´ ë§ì§€ ì•Šë‹¤.
    
    
ì´ì²˜ëŸ¼ ìŠ¤íŠ¸ë¦¼ì„ ì œëŒ€ë¡œ ì‚¬ìš©í•˜ë©´, ì½”ë“œë¥¼ ì§§ê³  ê¹”ë”í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆê³  ê°€ë…ì„±ë„ ë†’ì¼ ìˆ˜ ìˆë‹¤.

í•˜ì§€ë§Œ **ê³¼í•˜ê²Œ** ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•˜ë©´ ì˜¤íˆë ¤ ì½ê¸° ì–´ë µê³  ìœ ì§€ë³´ìˆ˜ë„ í˜ë“¤ì–´ ì§„ë‹¤.

## ğŸ’â€â™‚ï¸ ê³¼ë„í•œ ìŠ¤íŠ¸ë¦¼ ì‚¬ìš©

> Anagrams ì˜ˆì‹œ ì½”ë“œ ( ìŠ¤íŠ¸ë¦¼ X )

```java
public class Anagrams {

    public static void main(String[] args) throws FileNotFoundException {
        File dictionary = new File("src/test/resources/dictionary.txt");
        int minGroupSize = 3;

        Map<String, Set<String>> groups = new HashMap<>();
        try (Scanner scanner = new Scanner(dictionary)) {
            while (scanner.hasNext()) {
                String word = scanner.next();
                groups.computeIfAbsent(alphabetize(word),
                    (unused) -> new TreeSet<>()).add(word);
            }
        }

        for (Set<String> group : groups.values()) {
            if (group.size() >= minGroupSize) {
                System.out.println(group.size() + ": " + group);
            }
        }
    }

    private static String alphabetize(String word) {
        char[] alphabets = word.toCharArray();
        Arrays.sort(alphabets);
        return new String(alphabets);
    }
}
```

- ì•„ë‚˜ê·¸ë¨ì´ë€ ì² ìë¥¼ êµ¬ì„±í•˜ëŠ” ì•ŒíŒŒë²³ì´ ê°™ê³  ìˆœì„œë§Œ ë‹¤ë¥¸ ë‹¨ì–´ë“¤ì„ ë§í•œë‹¤.

- `computeIfAbsent` : ë§µ ì•ˆì— í‚¤ê°€ ìˆë‹¤ë©´ ê°’ì„ ë°˜í™˜í•˜ê³ , ê°’ì„ ìƒì„±í•œ í›„ í•¨ìˆ˜ ê°ì²´ë¥¼ í‚¤ë¡œ í•˜ì—¬ ë§¤í•‘í•œë‹¤.

í•´ë‹¹ ì½”ë“œì— streamì„ ê³¼í•˜ê²Œ ì ìš©í•´ë³´ì.

> ê³¼í•œ ìŠ¤íŠ¸ë¦¼ ì ìš© ê²°ê³¼

```java
public class Anagrams {
	public static void main(String[] args) throws IOException {
		Path dictionary = Paths.get(args[0]); 
		int minGroupSize = Integer.parseInt(args[1]); 

		try (Stream<String> words = Files.lines(dictionary)) { 
			// í•˜ë‚˜ì˜ í‘œí˜„ì‹ìœ¼ë¡œ ë³€ê²½ ê°€ëŠ¥
			words.collect(
					groupingBy(word -> word.chars().sorted()
							.collect(StringBuilder::new,
									(sb, c) -> sb.append((char) c),
									StringBuilder::append).toString()))
					.values().stream()
					.filter(group -> group.size() >= minGroupSize) //
					.map(group -> group.size() + " : " + group)
					.forEach(System.out::println);
		}
	}
}
```

- ì‚¬ì „ì„ ì—¬ëŠ” ë¶€ë¶„ì„ ì œì™¸í•˜ê³ ëŠ” ëª¨ë“  ê³¼ì •ì„ í•˜ë‚˜ì˜ í¬í˜„ì‹ìœ¼ë¡œ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤.

- ê·¸ë˜ì„œ ì½”ë“œ ê¸¸ì´ ì¸¡ë©´ì—ì„œ ì´ì ì„ ë³´ì´ê³  ìˆë‹¤.

- í•˜ì§€ë§Œ ì¤‘ìš”í•œ ê²ƒì€ **ì½ê¸°ê°€ ì–´ë µê³ , ìœ ì§€ë³´ìˆ˜ê°€ ì‰½ì§€ ì•Šë‹¤.**


> ì ì ˆí•œ ìŠ¤íŠ¸ë¦¼ í™œìš© 

```java
public class Anagrams {
	public static void main(String[] args) throws IOException {
		Path dictionary = Paths.get(args[0]); // ì‚¬ì „ íŒŒì¼ ê²½ë¡œ
		int minGroupSize = Integer.parseInt(args[1]); // ì‚¬ìš©ìê°€ ì§€ì •í•œ ì›ì†Œ ìˆ˜ ë¬¸í„±ê°’

		try (Stream<String> words = Files.lines(dictionary)) { 
			words.collect(groupingBy(Anagrams::alphabetize))
					.values().stream()
					.filter(group -> group.size() >= minGroupSize) 
					.forEach(g -> System.out.println(g.size() + " : " + g)); 
		}
	}

	// keyë¥¼ ë§Œë“œëŠ” ë©”ì„œë“œë¥¼ ë¶„ë¦¬ ( ë„ìš°ë¯¸ ë©”ì„œë“œ )
	private static String alphabetize(String s) {
		char[] a = s.toCharArray();
		Arrays.sort(a);
		return new String(a);
	}
}

```

- ì½”ë“œ ê¸¸ì´ëŠ” ê¸¸ì–´ì¡Œì§€ë§Œ, ì˜¤íˆë ¤ ë” ê¹”ë”í•´ì§€ê³  ëª…ë£Œí•´ì¡Œë‹¤.

- keyë¥¼ ë§Œë“œëŠ” ë©”ì„œë“œë¥¼ ìŠ¤íŠ¸ë¦¼ ë°–ìœ¼ë¡œ ë¹¼ë‚´ê³ , ì ì ˆí•œ ë©”ì„œë“œ ì´ë¦„ì„ ì§€ì–´ì¤Œìœ¼ë¡œì¨ ê°€ë…ì„±ì„ ë†’ì˜€ë‹¤.

> ğŸ™‹â€â™‚ï¸ char ì—°ì‚°ì€ ì‚¼ê°€í•˜ëŠ” í¸ì´ ë‚«ë‹¤.

> ìŠ¤íŠ¸ë¦¼ì´ ì§€ì›í•˜ëŠ” ê¸°ë³¸íƒ€ì…ì€ int, long, doubleì´ë‹¤. <br>
> ì¦‰ ë‚˜ë¨¸ì§€ ê¸°ë³¸íƒ€ì…(short, float, char ...)ì€ ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤. <br>
> í˜•ë³€í™˜ì„ ë„£ì–´ì„œ í•´ê²°í•  ìˆ˜ ëŠ” ìˆì§€ë§Œ ì¶”ì²œí•˜ì§€ ì•ŠëŠ”ë‹¤.

## í•¨ìˆ˜ê°ì²´ ğŸ†š  ì½”ë“œë¸”ëŸ­

```java
// í•¨ìˆ˜ ê°ì²´ ì˜ˆì‹œ
System.out::println
// ëŒë‹¤ ì˜ˆì‹œ
group -> group.size() >= minGroupSize
```
ìœ„ì—ì„œ ë³¸ ê²ƒì²˜ëŸ¼ ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ ë¼ì¸ì€ ë˜í’€ì´ë˜ëŠ” ê³„ì‚°ì„ **í•¨ìˆ˜ê°ì²´(ëŒë‹¤ í˜¹ì€ ë©”ì„œë“œ ì°¸ì¡°)** ë¡œ í‘œí˜„í•œë‹¤.

```java
List<String> names = List.of("kim","park","lee");
for {
    System.out.println(name);
}
```
ë°˜ë©´, ë°˜ë³µ ì½”ë“œëŠ” ì½”ë“œ ë¸”ëŸ­ìœ¼ë¡œ í‘œí˜„ì„ í•œë‹¤.

ê·¸ëŸ°ë° í•¨ìˆ˜ ê°ì²´ë¡œëŠ” í•  ìˆ˜ ì—†ì§€ë§Œ ì½”ë“œ ë¸”ë¡ìœ¼ë¡œ í•  ìˆ˜ ìˆëŠ” ì¼ì´ ì¡´ì¬í•œë‹¤.

### ì½”ë“œ ë¸”ëŸ­ì˜ íŠ¹ì§• 1ï¸âƒ£ - ì½”ë“œ ë¸”ë¡ì—ì„œëŠ” ë²”ìœ„ ì•ˆì˜ ì§€ì—­ë³€ìˆ˜ë¥¼ ì½ê³  ìˆ˜ì •í•  ìˆ˜ ìˆë‹¤.

```java
public static void main(String[] args) {
    List<Integer> numbers = List.of(1, 2, 3, 4, 5);
    int sum = 0; 

    numbers.stream().forEach(n -> {
        sum += n;  // ì»´íŒŒì¼ ì˜¤ë¥˜
    });
}
```

> ì‹¤í–‰ê²°ê³¼

```
local variables referenced from a lambda expression must be final or effectively final
```

- ì½”ë“œ ë¸”ëŸ­ì€ ë²”ìœ„ ì•ˆì˜ ì§€ì—­ë³€ìˆ˜ë¥¼ ëª¨ë‘ ì½ê³  ìˆ˜ì •í•  ìˆ˜ ìˆë‹¤.

- ë°˜ë©´ ìœ„ ì˜ˆì‹œ ì²˜ëŸ¼ í•¨ìˆ˜ ê°ì²´ëŠ” **ì‚¬ì‹¤ìƒ final ë³€ìˆ˜ë§Œ ì½ì„ ìˆ˜ ìˆê³ , ìˆ˜ì •í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤.**

### ì½”ë“œ ë¸”ëŸ­ì˜ íŠ¹ì§• 2ï¸âƒ£ - ë©”ì„œë“œ ì¤‘ê°„ì— ë‚˜ê°€ê±°ë‚˜ ì˜ˆì™¸ë¥¼ ë˜ì§ˆ ìˆ˜ ìˆë‹¤.

- `return`ì„ ì‚¬ìš©í•´ì„œ ë©”ì„œë“œì—ì„œ ë¹ ì ¸ë‚˜ê°ˆ ìˆ˜ ìˆë‹¤.

- í˜¹ì€ `break`ë‚˜ `continue`ë¡œ ë°˜ë³µë¬¸ ë°”ê¹¥ìœ¼ë¡œ ë‚˜ê°€ê±°ë‚˜ ê±´ë„ˆë›¸ ìˆ˜ ìˆë‹¤.

- ê²Œë‹¤ê°€ ë©”ì„œë“œ ì„ ì–¸ì—ì„œ ëª…ì‹œí•œ ì˜ˆì™¸ ë˜í•œ ë˜ì§ˆ ìˆ˜ ìˆë‹¤.

- í•˜ì§€ë§Œ í•¨ìˆ˜ê°ì²´ëŠ” ê·¸ ì–´ë–¤ ê²ƒë„ í•  ìˆ˜ ì—†ë‹¤.


ê·¸ë˜ì„œ ìœ„ 2ê°€ì§€ ê²½ìš°ê°€ í•„ìš”í•˜ê±°ë‚˜, ê·¸ ì´ìƒì˜ ì¼ì„ ìˆ˜í–‰í•´ì•¼ í•œë‹¤ë©´ ìŠ¤íŠ¸ë¦¼ë³´ë‹¤ **ì½”ë“œ ë¸”ëŸ­ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.**

### ğŸ‘ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì²˜ë¦¬í•˜ê¸° ì¢‹ì€ ê²½ìš°

ë°˜ëŒ€ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ëŠ” ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

1. ì›ì†Œë“¤ì„ ì¼ê´€ë˜ê²Œ ë³€í™˜í•˜ëŠ” ê²½ìš°

2. ì›ì†Œë“¤ì„ í•„í„°ë§í•˜ëŠ” ê²½ìš°

3. ì›ì†Œë“¤ì„ í•˜ë‚˜ì˜ ì—°ì‚°ì„ ì‚¬ìš©í•´ ê²°í•©í•˜ëŠ” ê²½ìš°

4. ì›ì†Œë“¤ì„ ì»¬ë ‰ì…˜ìœ¼ë¡œ ëª¨ìœ¼ëŠ” ê²½ìš°

5. íŠ¹ì • ì¡°ê±´ì„ ë§ì¡±í•˜ëŠ” ì›ì†Œë¥¼ ì°¾ëŠ” ê²½ìš°

## ğŸ¤¦â€â™‚ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì²˜ë¦¬í•˜ê¸° ì–´ë ¤ìš´ ê²½ìš° : ì—¬ëŸ¬ ë‹¨ê³„ì—ì„œì˜ ì›ì†Œ ê°’ì— ë™ì‹œì— ì ‘ê·¼í•˜ëŠ” ê²½ìš°

- ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ë¼ì¸ì€ ì›ì†Œë¥¼ **ë‹¤ë¥¸ ì›ì†Œë¡œ ë§¤í•‘í•˜ê³  ë‚˜ë©´ ê°’ì„ ì½ì–´ë²„ë¦¬ê²Œ ëœë‹¤.**

- ì›ë˜ ê°’ê³¼ ìƒˆë¡œìš´ ê°’ì˜ ìŒì„ ë”°ë¡œ ì €ì¥í•˜ì—¬ ë§¤í•‘í•˜ëŠ” ë°©ë²•ë„ ìˆê¸´ í•˜ë‹¤.

- í•˜ì§€ë§Œ ê·¸ë ‡ê²Œ ë˜ë©´ ìŠ¤íŠ¸ë¦¼ ë³¸ë˜ì˜ ëª©ì ì¸ ê¹”ë”í•œ ì½”ë“œì™€ëŠ” ë©€ì–´ì§€ê²Œ ëœë‹¤.

- ê·¸ë˜ì„œ ê°€ëŠ¥í•˜ë‹¤ë©´, ì¤‘ê°„ ì—°ì‚°ì—ì„œ í–ˆë˜ ê³¼ì •ì„ ê±°ê¾¸ë¡œí•´ì„œ ìˆ˜í–‰í•´ì„œ ì–»ëŠ” ê²ƒì´ ì¢‹ë‹¤.

> ì˜ˆì‹œ : ë©”ë¥´ì„¼ ì†Œìˆ˜

> í˜•íƒœê°€ $2^p-1$ ë¡œ í‘œí˜„ë˜ëŠ” ì†Œìˆ˜ <br>
> $p$ê°€ ì†Œìˆ˜ì¼ ë•Œ, $2^p-1$ì´ ì†Œìˆ˜ì¸ ê²½ìš° ë©”ë¥´ì„¼ ì†Œìˆ˜ë¼ê³  í•œë‹¤.

```java
public static void main(String[] args) {
    System.out.println("ë©”ë¥´ì„¼ ì†Œìˆ˜");
    primes().map(prime -> TWO.pow(prime.intValueExact()).subtract(ONE))
            .filter(mersenne -> mersenne.isProbablePrime(50))
            .limit(20)
            .forEach(System.out::println); 
}

public static Stream<BigInteger> primes() {
    return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```

> ì¶œë ¥ ê²°ê³¼

```
ë©”ë¥´ì„¼ ì†Œìˆ˜
3
7
31
127
8191
131071
524287
2147483647
```

ì—¬ê¸°ì„œ ë©”ë¥´ì„¼ ì†Œìˆ˜( $2^p-1$ ) ì—ì„œ ì‚¬ìš©ëœ pê°€ ê¶ê¸ˆí•˜ë‹¤ë©´ ì–´ë–»ê²Œ í•´ì•¼í• ê¹Œ?

```java
public static void main(String[] args) {
    System.out.println("p : ë©”ë¥´ì„¼ ì†Œìˆ˜ ì¶œë ¥ ê²°ê³¼");
    primes().map(prime -> TWO.pow(prime.intValueExact()).subtract(ONE))
            .filter(mersenne -> mersenne.isProbablePrime(50))
            .limit(20)
            .forEach(prime -> System.out.println(prime.bitLength() + ": " + prime)); // bitLength()ë¡œ ì§€ìˆ˜ë¥¼ êµ¬í•œë‹¤.
}

public static Stream<BigInteger> primes() {
    return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```

> ì¶œë ¥ ê²°ê³¼

```
p : ë©”ë¥´ì„¼ ì†Œìˆ˜ ì¶œë ¥ ê²°ê³¼
2: 3
3: 7
5: 31
7: 127
13: 8191
17: 131071
19: 524287
31: 2147483647
```

- ì¢…ë‹¨ ì—°ì‚°ì—ì„œ ì¤‘ê°„ ì—°ì‚°ì—ì„œ ìˆ˜í–‰í•œ ë§¤í•‘ì„ ê±°ê¾¸ë¡œ ìˆ˜í–‰í•´ êµ¬í•  ìˆ˜ ìˆë‹¤.

- ìœ„ ì˜ˆì‹œì—ì„œëŠ” `bitLength()`ë¡œ ì´ì§„ìˆ˜ë¡œ ë³€í™˜í›„ ëª‡ ë¹„íŠ¸ì¸ì§€ë¥¼ ê³„ì‚°í•˜ë©´ ì‰½ê²Œ êµ¬í• ìˆ˜ ìˆë‹¤.

í•˜ì§€ë§Œ ì´ëŸ¬í•œ ê²½ìš°ëŠ” ì¤‘ê°„ì—°ì‚°ì´ $2^p-1$ë¼ëŠ” íŠ¹ìˆ˜í•œ ì¡°ê±´ìœ¼ë¡œ ì¸í•´ ê°€ëŠ¥í•œ ê²ƒì´ë‹¤.

ì¤‘ê°„ ì—°ì‚°ì´ ë”ìš± ë³µì¡í•˜ë‹¤ë©´, ê° ë‹¨ê³„ë§ˆë‹¤ì˜ ì›ì†Œê°’ì„ êµ¬í•˜ê¸° í˜ë“¤ ê²ƒì´ë‹¤.

## ğŸ“š ì •ë¦¬

ìœ„ì—ì„œ ë´¤ë˜ ê²ƒ ì²˜ëŸ¼ ìŠ¤íŠ¸ë¦¼ê³¼ ë°˜ë³µ ë°©ì‹ ì¤‘ì—ì„œ í•œê°€ì§€ë¥¼ ê³ ë¥´ëŠ” ìƒí™©ì´ ìˆê¸´í•˜ì§€ë§Œ

ê°œì¸ì·¨í–¥ê³¼ í”„ë¡œê·¸ë˜ë° í™˜ê²½ ë¬¸ì œë„ ìˆë‹¤.

ì°¸ê³ í• ë§Œí•œ ì§€ì¹¨ ì •ë„ë§Œ ì¡´ì¬í•˜ì§€ ì–´ëŠ ìª½ì„ ì„ íƒí•˜ëŠ” í™•ê³ ë¶€ë™í•œ ê·œì¹™ì€ ì—†ë‹¤.

ê·¸ë˜ì„œ ìŠ¤íŠ¸ë¦¼ê³¼ ë°˜ë³µ ì¤‘ì—ì„œ ì„ íƒì„ ê³ ë¯¼í•˜ê³  ìˆë‹¤ë©´, **ë‘˜ ë‹¤ í•´ë³´ê³  ë” ë‚˜ì€ ìª½ì„ ì„ íƒí•˜ì.**
